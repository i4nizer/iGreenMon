<template>
    <v-container fluid class="bg-container pa-5 py-7">
        <v-row>
            <v-col>
                <h3>Greenhouse Reports</h3>
            </v-col>
        </v-row>
        <v-row>
            <!-- Reading Pagination -->
            <v-col class="pl-3 py-1" cols="12" sm="6">
                <v-select
                    chips
                    hide-details
                    label="Limit"
                    v-model="pagination.limit"
                    :items="[25, 50, 100, 200, 500]"
                    :disabled="printing"
                    @update:model-value="onUpdatePagination"
                ></v-select>
            </v-col>
            <v-col class="pr-3 py-1" cols="12" sm="6">
                <v-date-input
                    hide-details
                    label="Range"
                    variant="outlined"
                    density="compact"
                    multiple="range"
                    prepend-icon=""
                    prepend-inner-icon="mdi-calendar"
                    v-model="pagination.range"
                    :disabled="printing"
                    @update:model-value="onUpdatePagination"
                ></v-date-input>
            </v-col>
            <v-col class="pr-3 py-1" cols="10">
                <v-select
                    chip
                    multiple
                    hide-details
                    label="Outputs"
                    v-model="outputSelection"
                    :items="outputs"
                    :disabled="printing"
                    :item-title="(o) => o.name"
                    :item-value="(o) => o"
                ></v-select>
            </v-col>
            <v-col class="pr-3 py-1 d-flex align-center" cols="2">
                <v-btn
                    text="Print"
                    color="blue"
                    class="w-100"
                    elevation="0"
                    append-icon="mdi-file-document"
                    :loading="printing"
                    :disabled="printing"
                    @click="onClickPrint"
                ></v-btn>
            </v-col>
        </v-row>
        <v-row>
            <v-col>
                <v-divider></v-divider>
            </v-col>
        </v-row>
        <v-row id="printContent" style="padding: 96px">
            <!-- Print Header -->
            <v-col 
                cols="12" 
                class="text-center px-12 pt-16 mb-10" 
                style="z-index: 1; font-family: 'Times New Roman', Times, serif"
            >
                <h2>{{ gh?.name }} Reports</h2>
                <span class="text-grey">
                    <span>from </span>
                    <span v-if="dateAlpha">
                        {{ date.format(dateAlpha, "fullDateTime12h") }}
                    </span>
                    <span> to </span>
                    <span v-if="dateOmega">
                        {{ date.format(dateOmega, "fullDateTime12h") }}
                    </span>
                    <span class="text-grey">
                        generated by {{ user?.name }}.
                    </span>
                </span>
            </v-col>
            <!-- Print Charts -->
            <v-col 
                v-for="output in outputSelection"
                cols="12" 
                xs="12" 
                xl="6"
                class="d-flex flex-column ga-0 px-12 pr-16"
                :key="output.id"
            >
                <div 
                    class="border px-5 py-2 bg-green-darken-4"
                    style="z-index: 1"
                >
                    <strong>{{ output.name }}</strong>
                </div>
                <reading-line-chart
                    style="z-index: 1"
                    class="bg-white border pa-2 pl-5 pr-10"
                    :label="output.name"
                    :readings="readings.filter((r) => r.outputId == output.id)"
                ></reading-line-chart>
            </v-col>
        </v-row>
    </v-container>
</template>

<script setup lang="ts">
import type { Greenhouse } from '~~/shared/schema/greenhouse'
import type { Output } from '~~/shared/schema/output'

//

// --- Nuxt CTX
const nctx = useNuxtApp()
const rwnctx = nctx.runWithContext

// --- User
const userUtil = useUser()
const { user } = userUtil

// --- Notif
const toastUtil = useToast()

// --- Route Data
const routeUtil = useRoute()
const ghname = routeUtil.params?.ghname as string

// --- SSR'ed state
const ssred = useState<boolean>(`${ghname}-reports`, () => false)
onBeforeUnmount(() => ssred.value = false)

// --- Greenhouse
const ghUtil = useGreenhouse()
const gh = useState<Greenhouse | undefined>(`gh-${ghname}`)
const isOwnGH = computed(() => gh.value?.userId == user.value?.id)

const fetchGH = async () => {
    if (gh.value) return
	const res = await ghUtil.retrieve(ghname)
	if (!res.success) return toastUtil.error(res.error)
	gh.value = res.data
}

// --- Permissions
const permUtil = usePermission()
const permStore = usePermissionStore()
const { permissions } = permStore
const { canAccess } = permUtil

const fetchPerms = async () => {
	if (isOwnGH.value || permissions.length > 0) return;
	const res = await permUtil.retrieveAll(ghname)
	if (!res.success) return toastUtil.error(res.error)
	res.data.forEach((p) => permStore.append(p))
}

// --- Outputs
const outputUtil = useOutput()
const outputStore = useOutputStore()
const { outputs } = outputStore
const canAccessOutput = computed(() => canAccess("Output", permissions))

const fetchOutputs = async (force: boolean = false) => {
    if (!isOwnGH.value && !canAccessOutput.value) return
    if (!force && ssred.value) return
    const res = await outputUtil.retrieveAllByGH(ghname)
    if (!res.success) return toastUtil.error(res.error)
    outputs.splice(0, outputs.length)
    res.data.forEach((o) => outputStore.append(o))
}

// --- Reading
const readingUtil = useReading()
const readingStore = useReadingStore()
const { readings } = readingStore
const canAccessReading = computed(() => canAccess("Reading", permissions))

const fetchReadings = async (force: boolean = false) => {
    if (!isOwnGH.value && !canAccessReading.value) return
    if (!force && ssred.value) return

    const alpha = pagination.range.at(0)
    const omega = pagination.range.at(-1)

    const res = await readingUtil.retrieveAllByGH(
        ghname,
        alpha ? new Date(alpha) : undefined,
        omega ? new Date(omega) : undefined,
        pagination.limit,
        pagination.offset,
    )

    if (!res.success) return toastUtil.error(res.error)
    readings.splice(0, readings.length)
    res.data.forEach((r) => readingStore.append(r))
}

// --- Output Selection
const outputSelection = useState<Output[]>(`outputs`, () => [])

// --- Reading Pagination
const { execute: onUpdatePagination } = useDebounce(() => fetchReadings(true), 500)

const pagination = reactive({
    page: 0,
    count: 0,
    range: [new Date(Date.now() - 24 * 60 * 60 * 1000), new Date()],
    limit: 25,
    offset: 0,
})

// --- Header Formatting
const date = useDate()
const dateAlpha = computed(() => pagination.range.at(0))
const dateOmega = computed(() => pagination.range.at(-1))

// --- Reports Printing
const printing = ref(false)

const onClickPrint = async () => {
    try {
        const printElement = document.getElementById("printContent")
        if (!printElement || !gh.value) return
        printing.value = true

        // --- Dynamically import to avoid errors
        await nextTick()
        const { jsPDF } = await import("jspdf")
        const html2canvas = (await import("html2canvas")).default

        // --- Create A4 report
        const pdf = new jsPDF({
            orientation: "p",
            unit: "px",
            format: "a4",
            hotfixes: ["px_scaling"],
        })

        // --- 96px = 1inch
        const pdfWidth = pdf.internal.pageSize.getWidth()
        const pdfHeight = pdf.internal.pageSize.getHeight()

        // --- Create canvas of the element
        const canvas = await html2canvas(printElement, {
            width: printElement.scrollWidth,
            height: printElement.scrollHeight,
        })

        // --- Convert canvas to image in ratio
        const imgData = canvas.toDataURL("image/png")
        const imgWidth = pdfWidth
        const imgHeight = (canvas.height * imgWidth) / canvas.width

        // --- Record increments
        let heightLeft = imgHeight
        let heightUsed = 0

        // --- Slice the first part of the image
        pdf.addImage(imgData, "PNG", 0, heightUsed, imgWidth, imgHeight)
        heightLeft -= pdfHeight
        
        // --- Pull up the image
        while (heightLeft > 0) {
            heightUsed -= pdfHeight
            pdf.addPage()
            pdf.addImage(imgData, "PNG", 0, heightUsed, imgWidth, imgHeight)
            heightLeft -= pdfHeight
        }

        pdf.save(`${gh.value.name}-reports.pdf`)
    } catch (error) {
        console.error(error)
        toastUtil.error("Something went wrong.")
    } finally {
        printing.value = false
    }
}

// --- Data Fetching
const fetchData = async () => {
    await rwnctx(fetchGH)
    await rwnctx(fetchPerms)
    await Promise.all([
        rwnctx(fetchOutputs),
        rwnctx(fetchReadings),
    ])
    outputSelection.value.splice(0, outputSelection.value.length)
    outputSelection.value.push(...outputs)
    ssred.value = ssred.value || import.meta.server
}

onBeforeMount(fetchData)
onServerPrefetch(fetchData)

//

</script>

<style scoped>

</style>